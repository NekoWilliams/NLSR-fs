# 問題と解決策のまとめ

## 検証実施日
2025-11-12

## 現在の状況

### ✅ 確認できたこと
1. **新しいビルドがデプロイされている**
   - バイナリにsidecar関連のシンボルが285個含まれている
   - `SidecarStatsHandler`、`sidecar-stats`などのシンボルが確認された

2. **設定ファイルが正しく設定されている**
   - `sidecar-log-path /var/log/sidecar/service.log` が設定されている
   - `service-function`セクションが存在し、重みが設定されている

3. **ログファイルが存在し、正常な形式**
   - ファイルサイズ: 391-806 bytes
   - 権限: `-rw-r--r--` (root:root)
   - JSON形式のデータが記録されている

4. **コードで監視機能が呼ばれている**
   - `nlsr.cpp`の108行目で`startLogMonitoring()`が呼ばれている
   - `SidecarStatsHandler`が正しく初期化されている（97行目）

---

## 発見された問題

### 問題1: 監視機能が動作していない 🔴

**症状**:
- ログファイルを更新してもNameLSAのシーケンス番号が更新されない
- 現在のシーケンス番号: 1（更新されていない）
- 期待される動作: ログファイル更新後、5秒以内にシーケンス番号が増加するはず

**検証結果**:
- ログファイルに新しいエントリを追加
- 6秒待機（監視間隔5秒 + マージン）
- **結果**: シーケンス番号は1のまま（更新されていない）

**考えられる原因**:

#### 原因A: 監視機能が起動していない
- `startLogMonitoring()`が呼ばれているが、実際にはスケジュールされていない
- スケジューラーのイベントが正しく登録されていない
- エラーが発生しているがログに出力されていない

#### 原因B: ログファイルの変更検出が動作していない
- ハッシュ計算が正しく動作していない
- ファイル読み取りに失敗している
- ハッシュ比較のロジックに問題がある

#### 原因C: NameLSA更新処理が失敗している
- `updateNameLsaWithStats()`が呼ばれていない
- 統計情報の抽出に失敗している
- NameLSAの検索に失敗している

---

### 問題2: NLSRのログが空 ⚠️

**症状**:
- `kubectl logs`でログが取得できない（空）
- ログレベル: `NDN_LOG=nlsr.*=INFO` → `DEBUG`に変更済み
- デバッグログが出力されていない

**検証結果**:
- ログレベルをDEBUGに変更したが、ログが空のまま
- 監視関連のログメッセージが見つからない

**考えられる原因**:

#### 原因A: ログが別の場所に出力されている
- ログがファイルに出力されている（stdout/stderrではない）
- ログがsyslogに出力されている
- ログバッファリングの問題

#### 原因B: ログシステムが正しく初期化されていない
- ログレベルの設定が反映されていない
- ログハンドラーが正しく設定されていない

#### 原因C: NLSRが実際には起動していない
- プロセスは存在するが、初期化が完了していない
- エラーで早期終了している

---

### 問題3: sidecar-stats datasetにアクセスできない ⚠️

**症状**:
- `nlsrc status sidecar-stats`がタイムアウトする
- データセットハンドラーが正しく登録されていない可能性

**検証結果**:
- タイムアウトが発生（5秒待機）

**考えられる原因**:

#### 原因A: Dispatcherの初期化に問題がある
- トップレベルプレフィックスが正しく設定されていない
- ハンドラーの登録順序に問題がある

#### 原因B: ネットワークの問題
- ローカルホストへの接続に問題がある
- ポートが正しく開いていない

---

## 解決策

### 解決策1: デバッグログの追加 ✅（実施済み）

**実施内容**:
- `startLogMonitoring()`に詳細なデバッグログを追加
- `updateNameLsaWithStats()`に各ステップのログを追加
- `parseSidecarLog()`にパース処理のログを追加

**期待される効果**:
- 監視機能が実際に起動しているか確認できる
- どのステップで問題が発生しているか特定できる
- ログファイルの読み取りが成功しているか確認できる

**次のステップ**:
1. 新しいビルドをデプロイ
2. デバッグログを確認
3. 問題の原因を特定

---

### 解決策2: ログ出力先の確認

**実施方法**:
```bash
# ログファイルの場所を確認
kubectl exec <pod> -- find /var/log -name "*nlsr*" 2>/dev/null

# syslogを確認
kubectl exec <pod> -- journalctl -u nlsr 2>/dev/null || echo "journalctl not available"

# 標準出力/標準エラー出力を確認
kubectl exec <pod> -- ls -la /proc/$(pgrep nlsr)/fd/ 2>/dev/null
```

**期待される効果**:
- ログがどこに出力されているか特定できる
- ログを正しく取得できるようになる

---

### 解決策3: 手動での動作確認

**実施方法**:
1. **監視機能を手動でトリガー**
   - コードを修正して、起動時に一度だけ`updateNameLsaWithStats()`を呼ぶ
   - NameLSAが更新されるか確認

2. **ログパーサーを直接テスト**
   - テストプログラムを作成して、ログパーサーが正しく動作するか確認
   - 統計情報が正しく抽出されるか確認

3. **NameLSA更新を直接テスト**
   - `nlsrc`コマンドを使って手動でNameLSAを更新
   - Service Function情報が含まれるか確認

**期待される効果**:
- 各機能が個別に動作するか確認できる
- 問題の原因を特定できる

---

### 解決策4: スケジューラーの動作確認

**問題の可能性**:
- `scheduler.schedule()`が正しく動作していない
- イベントがスケジュールされても実行されていない

**確認方法**:
1. スケジューラーの状態を確認
2. イベントが正しく登録されているか確認
3. イベントの実行タイミングを確認

**修正案**:
- スケジューラーの代わりに、別の方法で監視を実装
- 例: ポーリングベースの実装を確認

---

### 解決策5: エラーハンドリングの強化

**実施内容**:
- すべてのエラーケースで適切なログを出力
- 例外がキャッチされているか確認
- エラーメッセージを詳細化

**期待される効果**:
- エラーが発生している場合、その原因を特定できる

---

## 優先度別の対応

### 優先度: 最高 🔴

1. **デバッグログの確認**
   - 新しいビルドをデプロイ
   - デバッグログを確認して問題の原因を特定
   - **状態**: デバッグログは追加済み、ビルドとデプロイが必要

2. **ログ出力先の確認**
   - ログがどこに出力されているか確認
   - ログを正しく取得できるようにする

### 優先度: 高 ⚠️

3. **手動での動作確認**
   - 監視機能を手動でトリガーして動作を確認
   - 各機能が個別に動作するか確認

4. **スケジューラーの動作確認**
   - スケジューラーが正しく動作しているか確認
   - イベントが実行されているか確認

### 優先度: 中

5. **エラーハンドリングの強化**
   - より詳細なエラーメッセージを出力
   - すべてのエラーケースをカバー

---

## 推奨される次のステップ

### ステップ1: 新しいビルドのデプロイと検証
1. デバッグログを含む新しいビルドを作成
2. Kubernetes Podを再デプロイ
3. 検証スクリプトを実行: `./verify_with_debug.sh`

### ステップ2: ログの確認
1. デバッグログが出力されているか確認
2. 以下のログメッセージを探す:
   - `startLogMonitoring called`
   - `Log monitoring check triggered`
   - `Log file changed`
   - `updateNameLsaWithStats called`

### ステップ3: 問題の特定
1. ログが表示されない場合 → 監視機能が起動していない
2. `Cannot open log file` が表示される場合 → ファイルパスの問題
3. `No valid statistics available` が表示される場合 → パースの問題
4. `Own NameLSA not found` が表示される場合 → NameLSAの検索の問題

### ステップ4: 問題に応じた修正
1. 特定された問題に応じて修正を実施
2. 再度ビルドとデプロイ
3. 動作確認

---

## 技術的な詳細

### 監視機能の実装フロー

```
1. NLSR起動
   ↓
2. SidecarStatsHandler初期化
   ↓
3. startLogMonitoring()呼び出し
   ↓
4. 初期ハッシュ計算
   ↓
5. スケジューラーにイベント登録（5秒後）
   ↓
6. 監視チェック実行
   ├─ ログファイル読み取り
   ├─ ハッシュ計算
   ├─ 変更検出
   └─ 変更あり → updateNameLsaWithStats()
   ↓
7. 次のチェックをスケジュール（5秒後）
   ↓
8. 繰り返し
```

### 考えられる問題箇所

1. **ステップ3**: `startLogMonitoring()`が呼ばれていない
2. **ステップ4**: 初期ハッシュ計算に失敗
3. **ステップ5**: スケジューラーへの登録に失敗
4. **ステップ6**: 監視チェックが実行されない
5. **ステップ6**: ログファイルの読み取りに失敗
6. **ステップ6**: ハッシュ比較が正しく動作していない
7. **ステップ6**: `updateNameLsaWithStats()`が呼ばれない
8. **ステップ6**: NameLSA更新に失敗

---

## まとめ

### 現在の状態
- ✅ 新しいビルドがデプロイされている
- ✅ 設定ファイルが正しい
- ✅ ログファイルが存在する
- ✅ コードで監視機能が呼ばれている
- ❌ 監視機能が実際に動作していない
- ❌ ログが出力されていない
- ❌ NameLSAが更新されない

### 次のアクション
1. **デバッグログを含む新しいビルドをデプロイ**
2. **検証スクリプトを実行してログを確認**
3. **ログから問題の原因を特定**
4. **問題に応じた修正を実施**

### 期待される結果
デバッグログを確認することで、以下のいずれかが判明するはずです：
- 監視機能が起動していない理由
- ログファイルの読み取りに失敗している理由
- NameLSA更新に失敗している理由
- その他の問題

