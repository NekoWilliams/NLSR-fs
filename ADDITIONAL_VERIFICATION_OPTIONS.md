# 追加の検証選択肢

## 検証の種類

### 1. コードレベルの検証（ビルド前）

#### A. ログパーサーの単体テスト
**目的**: 修正した`parseSidecarLog()`が正しく動作するか確認

**方法**:
- 実際のログファイル形式のサンプルデータを作成
- パーサーが正しく値を抽出できるかテスト
- エッジケース（空のログ、不正な形式など）のテスト

**実施方法**:
```bash
# テスト用のログファイルを作成
cat > /tmp/test_sidecar.log << 'EOF'
{"sfc_time": "2025-11-12 02:58:50.676086", "service_call": {"call_name": "/relay", "in_time": "2025-11-12 02:58:50.676086", "out_time": "2025-11-12 02:58:50.677831", "port_num": 6363, "in_datasize": 13, "out_datasize": 13}, "sidecar": {"in_time": "2025-11-12 02:58:50.692365", "out_time": "2025-11-12 02:58:50.696276", "name": "ndn-sidecar", "protocol": "ndn"}, "host_name": "192.168.49.2"}
EOF

# パーサーの動作を確認（簡易テストスクリプトを作成）
```

**メリット**: ビルド前に問題を発見できる

---

#### B. タイムスタンプパース関数の検証
**目的**: `parseTimestamp()`関数が正しく動作するか確認

**方法**:
- 様々なタイムスタンプ形式でテスト
- エポック秒への変換が正しいか確認
- マイクロ秒の処理が正しいか確認

**実施方法**:
```cpp
// テストケース
"2025-11-12 02:58:50.676086" → 正しくパースできるか
"2025-11-12 02:58:50" → マイクロ秒なしの場合
"2025-01-01 00:00:00.000000" → 境界値テスト
```

**メリット**: 計算ロジックの正確性を確認できる

---

#### C. 統計情報抽出ロジックの検証
**目的**: `convertStatsToServiceFunctionInfo()`が正しく値を計算するか確認

**方法**:
- 様々なログエントリでテスト
- 処理時間の計算が正しいか確認
- フォールバック処理が正しく動作するか確認

**実施方法**:
```bash
# テストデータで処理時間を計算
# service_call: in_time - out_time = 0.001745秒
# sidecar: in_time - out_time = 0.003911秒
# どちらが優先されるか確認
```

**メリット**: ビジネスロジックの正確性を確認できる

---

### 2. ビルド検証

#### D. コンパイルエラーの確認
**目的**: 修正したコードが正しくコンパイルできるか確認

**方法**:
```bash
cd /home/katsutoshi/NLSR-fs
./waf configure
./waf
```

**確認ポイント**:
- コンパイルエラーがないか
- 警告メッセージの確認
- リンクエラーがないか

**メリット**: デプロイ前に問題を発見できる

---

### 3. 統合テスト（ビルド後、デプロイ前）

#### E. ローカルでの動作確認
**目的**: ビルドしたバイナリが正しく動作するか確認

**方法**:
- ローカル環境でNLSRを起動
- テスト用のログファイルを配置
- ログ監視が開始されるか確認
- NameLSAが更新されるか確認

**実施方法**:
```bash
# ローカルでNLSRを起動
./build/nlsr -f nlsr.conf

# 別ターミナルでログを確認
tail -f /var/log/nlsr/nlsr.log | grep -i sidecar

# テスト用ログファイルを作成
echo '{"service_call": {"in_time": "...", "out_time": "..."}, ...}' > /var/log/sidecar/service.log
```

**メリット**: 実際の環境に近い状態でテストできる

---

### 4. デプロイ後の検証

#### F. 段階的な動作確認
**目的**: 各機能が段階的に正しく動作するか確認

**ステップ1: ログファイル監視の確認**
```bash
# NLSRのログで監視開始を確認
kubectl logs <pod> | grep -i "monitoring\|sidecar"
```

**ステップ2: ログパースの確認**
```bash
# ログファイルを更新
kubectl exec <pod> -- sh -c 'echo "..." >> /var/log/sidecar/service.log'

# NLSRのログでパース結果を確認
kubectl logs <pod> | grep -i "parsed\|error"
```

**ステップ3: NameLSA更新の確認**
```bash
# シーケンス番号の変化を確認
kubectl exec <pod> -- nlsrc -k lsdb | grep "NAME LSA"
```

**メリット**: 問題の原因を特定しやすい

---

#### G. パフォーマンス検証
**目的**: ログ監視がシステムに与える影響を確認

**方法**:
- ログファイルの更新頻度とCPU使用率の関係
- メモリ使用量の確認
- ログパースの処理時間測定

**実施方法**:
```bash
# CPU使用率を監視
kubectl top pod <pod>

# ログファイルを頻繁に更新して影響を確認
for i in {1..100}; do
  echo "..." >> /var/log/sidecar/service.log
  sleep 0.1
done
```

**メリット**: 本番環境での問題を事前に発見できる

---

### 5. エラーハンドリングの検証

#### H. 異常系テスト
**目的**: エラーケースで正しく動作するか確認

**テストケース**:
1. **ログファイルが存在しない場合**
   ```bash
   kubectl exec <pod> -- rm /var/log/sidecar/service.log
   # NLSRがクラッシュしないか確認
   ```

2. **ログファイルが空の場合**
   ```bash
   kubectl exec <pod> -- sh -c '> /var/log/sidecar/service.log'
   # エラーメッセージが適切に出力されるか確認
   ```

3. **不正なJSON形式の場合**
   ```bash
   kubectl exec <pod> -- sh -c 'echo "invalid json" >> /var/log/sidecar/service.log'
   # パースエラーが適切に処理されるか確認
   ```

4. **ログファイルの権限エラー**
   ```bash
   kubectl exec <pod> -- chmod 000 /var/log/sidecar/service.log
   # エラーハンドリングが正しく動作するか確認
   ```

**メリット**: 本番環境での安定性を確認できる

---

### 6. データ整合性の検証

#### I. Service Function情報の正確性確認
**目的**: NameLSAに反映される情報が正しいか確認

**方法**:
1. ログファイルの内容を記録
2. NameLSAを取得してService Function情報を確認
3. 計算された値が正しいか検証

**実施方法**:
```bash
# ログファイルの内容を確認
kubectl exec <pod> -- cat /var/log/sidecar/service.log

# NameLSAを取得（TLVデコードが必要）
kubectl exec <pod> -- nlsrc -k lsdb | grep -A 20 "NAME LSA"

# 計算値と比較
# processingTime = out_time - in_time
```

**メリット**: データの正確性を保証できる

---

### 7. ネットワーク同期の検証

#### J. 他ノードでの同期確認
**目的**: 更新されたNameLSAが他のノードに正しく同期されるか確認

**方法**:
1. node1でNameLSAを更新
2. node2, node3, node4で同期を確認
3. Service Function情報が含まれているか確認

**実施方法**:
```bash
# node1でログファイルを更新
kubectl exec <node1-pod> -- sh -c 'echo "..." >> /var/log/sidecar/service.log'
sleep 10

# node2でnode1のNameLSAを確認
kubectl exec <node2-pod> -- nlsrc -k lsdb | grep -A 10 "node1"
```

**メリット**: ネットワーク全体での動作を確認できる

---

## 推奨される検証順序

### 優先度: 高（必須）
1. **D. コンパイルエラーの確認** - まずビルドできるか確認
2. **A. ログパーサーの単体テスト** - コア機能の動作確認
3. **F. 段階的な動作確認** - デプロイ後の基本動作確認

### 優先度: 中（推奨）
4. **B. タイムスタンプパース関数の検証** - 計算ロジックの正確性
5. **C. 統計情報抽出ロジックの検証** - ビジネスロジックの正確性
6. **H. 異常系テスト** - エラーハンドリングの確認

### 優先度: 低（オプション）
7. **E. ローカルでの動作確認** - 開発環境でのテスト
8. **G. パフォーマンス検証** - パフォーマンスチューニング
9. **I. Service Function情報の正確性確認** - 詳細なデータ検証
10. **J. 他ノードでの同期確認** - ネットワーク全体の動作確認

## 各検証の所要時間の目安

- **A, B, C**: 各30分〜1時間（コードレビューとテスト作成）
- **D**: 10分（ビルド時間）
- **E**: 1〜2時間（環境構築とテスト）
- **F**: 30分（デプロイと確認）
- **G**: 1時間（パフォーマンス測定）
- **H**: 1時間（各種エラーケースのテスト）
- **I**: 30分（データ検証）
- **J**: 30分（同期確認）

## 次のアクション

どの検証から始めますか？

1. **すぐにビルドして確認** → D → F（段階的確認）
2. **コードレベルで確認** → A → B → C → D
3. **包括的な検証** → すべての検証を順番に実施

